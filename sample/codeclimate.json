[
   {
     "engine_name": "csslint",
     "fingerprint": "b8adbf007da14b7262abdeef944e3531",
     "type": "issue",
     "check_name": "order-alphabetical",
     "description": "Rule doesn't have all its properties in alphabetical order.",
     "categories": [
       "Style"
     ],
     "remediation_points": 50000,
     "location": {
       "path": "src/public/stylesheets/style.css",
       "positions": {
         "begin": {
           "line": 1,
           "column": 1
         },
         "end": {
           "line": 1,
           "column": 1
         }
       }
     },
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ee3c68ec7f6b6406c0d10229edc4b921",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 1,
           "column": 1
         },
         "end": {
           "line": 1,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "a297cb2b88b66de37cd83c625856b1d5",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 1,
           "column": 33
         },
         "end": {
           "line": 1,
           "column": 33
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ee3c68ec7f6b6406c0d10229edc4b921",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 2,
           "column": 1
         },
         "end": {
           "line": 2,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "a297cb2b88b66de37cd83c625856b1d5",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 2,
           "column": 30
         },
         "end": {
           "line": 2,
           "column": 30
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "40605cb86aea959465d18d8f1928d836",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "space-before-function-paren",
     "description": "Missing space before function parentheses.",
     "content": {
       "body": "# Require or disallow a space before function parenthesis (space-before-function-paren)\n\nWhen formatting a function, whitespace is allowed between the function name or `function` keyword and the opening paren. Named functions also require a space between the `function` keyword and the function name, but anonymous functions require no whitespace. For example:\n\n```js\nfunction withoutSpace(x) {\n    // ...\n}\n\nfunction withSpace (x) {\n    // ...\n}\n\nvar anonymousWithoutSpace = function() {};\n\nvar anonymousWithSpace = function () {};\n```\n\nStyle guides may require a space after the `function` keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.\n\n## Rule Details\n\nThis rule aims to enforce consistent spacing before function parentheses and as such, will warn whenever whitespace doesn't match the preferences specified.\n\n## Options\n\nThis rule has a string option or an object option:\n\n```js\n{\n    \"space-before-function-paren\": [\"error\", \"always\"],\n    // or\n    \"space-before-function-paren\": [\"error\", {\n        \"anonymous\": \"always\",\n        \"named\": \"always\",\n        \"asyncArrow\": \"always\"\n    }],\n}\n```\n\n* `always` (default) requires a space followed by the `(` of arguments.\n* `never` disallows any space followed by the `(` of arguments.\n\nThe string option does not check async arrow function expressions for backward compatibility.\n\nYou can also use a separate option for each type of function.\nEach of the following options can be set to `\"always\"`, `\"never\"`, or `\"ignore\"`. The default is `\"always\"`.\n\n* `anonymous` is for anonymous function expressions (e.g. `function () {}`).\n* `named` is for named function expressions (e.g. `function foo () {}`).\n* `asyncArrow` is for async arrow function expressions (e.g. `async () => {}`).\n\n### \"always\"\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\n### \"never\"\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\n### `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async(a) => await a\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async (a) => await a\n```\n\n### `{\"anonymous\": \"never\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n### `{\"anonymous\": \"ignore\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function () {\n    // ...\n};\n\nfunction foo () {\n    // ...\n}\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n## When Not To Use It\n\nYou can turn this rule off if you are not concerned with the consistency of spacing before function parenthesis.\n\n## Related Rules\n\n* [space-after-keywords](space-after-keywords.md)\n* [space-return-throw-case](space-return-throw-case.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 5,
           "column": 25
         },
         "end": {
           "line": 5,
           "column": 25
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "a297cb2b88b66de37cd83c625856b1d5",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 6,
           "column": 44
         },
         "end": {
           "line": 6,
           "column": 44
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "a297cb2b88b66de37cd83c625856b1d5",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 7,
           "column": 3
         },
         "end": {
           "line": 7,
           "column": 3
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "a297cb2b88b66de37cd83c625856b1d5",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/index.js",
       "positions": {
         "begin": {
           "line": 9,
           "column": 24
         },
         "end": {
           "line": 9,
           "column": 24
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "628bbf5542f226599f10e805ac4ebe8b",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 1,
           "column": 1
         },
         "end": {
           "line": 1,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ea24926cbac6c12acf667de545402005",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 1,
           "column": 33
         },
         "end": {
           "line": 1,
           "column": 33
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "628bbf5542f226599f10e805ac4ebe8b",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 2,
           "column": 1
         },
         "end": {
           "line": 2,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ea24926cbac6c12acf667de545402005",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 2,
           "column": 30
         },
         "end": {
           "line": 2,
           "column": 30
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "add48ff42ba3fe6907aa9816e869daac",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "space-before-function-paren",
     "description": "Missing space before function parentheses.",
     "content": {
       "body": "# Require or disallow a space before function parenthesis (space-before-function-paren)\n\nWhen formatting a function, whitespace is allowed between the function name or `function` keyword and the opening paren. Named functions also require a space between the `function` keyword and the function name, but anonymous functions require no whitespace. For example:\n\n```js\nfunction withoutSpace(x) {\n    // ...\n}\n\nfunction withSpace (x) {\n    // ...\n}\n\nvar anonymousWithoutSpace = function() {};\n\nvar anonymousWithSpace = function () {};\n```\n\nStyle guides may require a space after the `function` keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.\n\n## Rule Details\n\nThis rule aims to enforce consistent spacing before function parentheses and as such, will warn whenever whitespace doesn't match the preferences specified.\n\n## Options\n\nThis rule has a string option or an object option:\n\n```js\n{\n    \"space-before-function-paren\": [\"error\", \"always\"],\n    // or\n    \"space-before-function-paren\": [\"error\", {\n        \"anonymous\": \"always\",\n        \"named\": \"always\",\n        \"asyncArrow\": \"always\"\n    }],\n}\n```\n\n* `always` (default) requires a space followed by the `(` of arguments.\n* `never` disallows any space followed by the `(` of arguments.\n\nThe string option does not check async arrow function expressions for backward compatibility.\n\nYou can also use a separate option for each type of function.\nEach of the following options can be set to `\"always\"`, `\"never\"`, or `\"ignore\"`. The default is `\"always\"`.\n\n* `anonymous` is for anonymous function expressions (e.g. `function () {}`).\n* `named` is for named function expressions (e.g. `function foo () {}`).\n* `asyncArrow` is for async arrow function expressions (e.g. `async () => {}`).\n\n### \"always\"\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\n### \"never\"\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\n### `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async(a) => await a\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async (a) => await a\n```\n\n### `{\"anonymous\": \"never\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n### `{\"anonymous\": \"ignore\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function () {\n    // ...\n};\n\nfunction foo () {\n    // ...\n}\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n## When Not To Use It\n\nYou can turn this rule off if you are not concerned with the consistency of spacing before function parenthesis.\n\n## Related Rules\n\n* [space-after-keywords](space-after-keywords.md)\n* [space-return-throw-case](space-return-throw-case.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 5,
           "column": 25
         },
         "end": {
           "line": 5,
           "column": 25
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ea24926cbac6c12acf667de545402005",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 6,
           "column": 38
         },
         "end": {
           "line": 6,
           "column": 38
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ea24926cbac6c12acf667de545402005",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 7,
           "column": 3
         },
         "end": {
           "line": 7,
           "column": 3
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "ea24926cbac6c12acf667de545402005",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/routes/users.js",
       "positions": {
         "begin": {
           "line": 9,
           "column": 24
         },
         "end": {
           "line": 9,
           "column": 24
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 1,
           "column": 1
         },
         "end": {
           "line": 1,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 1,
           "column": 41
         },
         "end": {
           "line": 1,
           "column": 41
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 2,
           "column": 1
         },
         "end": {
           "line": 2,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 2,
           "column": 33
         },
         "end": {
           "line": 2,
           "column": 33
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 3,
           "column": 1
         },
         "end": {
           "line": 3,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 3,
           "column": 27
         },
         "end": {
           "line": 3,
           "column": 27
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 4,
           "column": 1
         },
         "end": {
           "line": 4,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 4,
           "column": 44
         },
         "end": {
           "line": 4,
           "column": 44
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 5,
           "column": 1
         },
         "end": {
           "line": 5,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 5,
           "column": 31
         },
         "end": {
           "line": 5,
           "column": 31
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 7,
           "column": 1
         },
         "end": {
           "line": 7,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 7,
           "column": 44
         },
         "end": {
           "line": 7,
           "column": 44
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 8,
           "column": 1
         },
         "end": {
           "line": 8,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 8,
           "column": 44
         },
         "end": {
           "line": 8,
           "column": 44
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "e77f90d4c937e8ad8b0455b0a6be250e",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "no-var",
     "description": "Unexpected var, use let or const instead.",
     "content": {
       "body": "# require `let` or `const` instead of `var` (no-var)\n\nECMAScript 6 allows programmers to create variables with block scope instead of function scope using the `let`\nand `const` keywords. Block scope is common in many other programming languages and helps programmers avoid mistakes\nsuch as:\n\n```js\nvar count = people.length;\nvar enoughFood = count > sandwiches.length;\n\nif (enoughFood) {\n    var count = sandwiches.length; // accidentally overriding the count variable\n    console.log(\"We have \" + count + \" sandwiches for everyone. Plenty for all!\");\n}\n\n// our count variable is no longer accurate\nconsole.log(\"We have \" + count + \" people and \" + sandwiches.length + \" sandwiches!\");\n```\n\n## Rule Details\n\nThis rule is aimed at discouraging the use of `var` and encouraging the use of `const` or `let` instead.\n\n## Examples\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n\nvar x = \"y\";\nvar CONFIG = {};\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-var: \"error\"*/\n/*eslint-env es6*/\n\nlet x = \"y\";\nconst CONFIG = {};\n```\n\n## When Not To Use It\n\nIn addition to non-ES6 environments, existing JavaScript projects that are beginning to introduce ES6 into their\ncodebase may not want to apply this rule if the cost of migrating from `var` to `let` is too costly.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 10,
           "column": 1
         },
         "end": {
           "line": 10,
           "column": 1
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 10,
           "column": 20
         },
         "end": {
           "line": 10,
           "column": 20
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 13,
           "column": 48
         },
         "end": {
           "line": 13,
           "column": 48
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 14,
           "column": 30
         },
         "end": {
           "line": 14,
           "column": 30
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 16,
           "column": 23
         },
         "end": {
           "line": 16,
           "column": 23
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 17,
           "column": 24
         },
         "end": {
           "line": 17,
           "column": 24
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 18,
           "column": 49
         },
         "end": {
           "line": 18,
           "column": 49
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 19,
           "column": 24
         },
         "end": {
           "line": 19,
           "column": 24
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 20,
           "column": 56
         },
         "end": {
           "line": 20,
           "column": 56
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 22,
           "column": 26
         },
         "end": {
           "line": 22,
           "column": 26
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 23,
           "column": 31
         },
         "end": {
           "line": 23,
           "column": 31
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "9dfd6c8efcabd9e7c0928605cab7d792",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "space-before-function-paren",
     "description": "Missing space before function parentheses.",
     "content": {
       "body": "# Require or disallow a space before function parenthesis (space-before-function-paren)\n\nWhen formatting a function, whitespace is allowed between the function name or `function` keyword and the opening paren. Named functions also require a space between the `function` keyword and the function name, but anonymous functions require no whitespace. For example:\n\n```js\nfunction withoutSpace(x) {\n    // ...\n}\n\nfunction withSpace (x) {\n    // ...\n}\n\nvar anonymousWithoutSpace = function() {};\n\nvar anonymousWithSpace = function () {};\n```\n\nStyle guides may require a space after the `function` keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.\n\n## Rule Details\n\nThis rule aims to enforce consistent spacing before function parentheses and as such, will warn whenever whitespace doesn't match the preferences specified.\n\n## Options\n\nThis rule has a string option or an object option:\n\n```js\n{\n    \"space-before-function-paren\": [\"error\", \"always\"],\n    // or\n    \"space-before-function-paren\": [\"error\", {\n        \"anonymous\": \"always\",\n        \"named\": \"always\",\n        \"asyncArrow\": \"always\"\n    }],\n}\n```\n\n* `always` (default) requires a space followed by the `(` of arguments.\n* `never` disallows any space followed by the `(` of arguments.\n\nThe string option does not check async arrow function expressions for backward compatibility.\n\nYou can also use a separate option for each type of function.\nEach of the following options can be set to `\"always\"`, `\"never\"`, or `\"ignore\"`. The default is `\"always\"`.\n\n* `anonymous` is for anonymous function expressions (e.g. `function () {}`).\n* `named` is for named function expressions (e.g. `function foo () {}`).\n* `asyncArrow` is for async arrow function expressions (e.g. `async () => {}`).\n\n### \"always\"\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\n### \"never\"\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\n### `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async(a) => await a\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async (a) => await a\n```\n\n### `{\"anonymous\": \"never\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n### `{\"anonymous\": \"ignore\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function () {\n    // ...\n};\n\nfunction foo () {\n    // ...\n}\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n## When Not To Use It\n\nYou can turn this rule off if you are not concerned with the consistency of spacing before function parenthesis.\n\n## Related Rules\n\n* [space-after-keywords](space-after-keywords.md)\n* [space-return-throw-case](space-return-throw-case.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 26,
           "column": 17
         },
         "end": {
           "line": 26,
           "column": 17
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 27,
           "column": 25
         },
         "end": {
           "line": 27,
           "column": 25
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 28,
           "column": 3
         },
         "end": {
           "line": 28,
           "column": 3
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "9dfd6c8efcabd9e7c0928605cab7d792",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "space-before-function-paren",
     "description": "Missing space before function parentheses.",
     "content": {
       "body": "# Require or disallow a space before function parenthesis (space-before-function-paren)\n\nWhen formatting a function, whitespace is allowed between the function name or `function` keyword and the opening paren. Named functions also require a space between the `function` keyword and the function name, but anonymous functions require no whitespace. For example:\n\n```js\nfunction withoutSpace(x) {\n    // ...\n}\n\nfunction withSpace (x) {\n    // ...\n}\n\nvar anonymousWithoutSpace = function() {};\n\nvar anonymousWithSpace = function () {};\n```\n\nStyle guides may require a space after the `function` keyword for anonymous functions, while others specify no whitespace. Similarly, the space after a function name may or may not be required.\n\n## Rule Details\n\nThis rule aims to enforce consistent spacing before function parentheses and as such, will warn whenever whitespace doesn't match the preferences specified.\n\n## Options\n\nThis rule has a string option or an object option:\n\n```js\n{\n    \"space-before-function-paren\": [\"error\", \"always\"],\n    // or\n    \"space-before-function-paren\": [\"error\", {\n        \"anonymous\": \"always\",\n        \"named\": \"always\",\n        \"asyncArrow\": \"always\"\n    }],\n}\n```\n\n* `always` (default) requires a space followed by the `(` of arguments.\n* `never` disallows any space followed by the `(` of arguments.\n\nThe string option does not check async arrow function expressions for backward compatibility.\n\nYou can also use a separate option for each type of function.\nEach of the following options can be set to `\"always\"`, `\"never\"`, or `\"ignore\"`. The default is `\"always\"`.\n\n* `anonymous` is for anonymous function expressions (e.g. `function () {}`).\n* `named` is for named function expressions (e.g. `function foo () {}`).\n* `asyncArrow` is for async arrow function expressions (e.g. `async () => {}`).\n\n### \"always\"\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint space-before-function-paren: \"error\"*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\n### \"never\"\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nvar bar = function foo () {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async () => 1\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", \"never\"]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function foo() {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async() => 1\n```\n\n### `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n\nvar foo = async(a) => await a\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", {\"anonymous\": \"always\", \"named\": \"never\", \"asyncArrow\": \"always\"}]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n\nvar foo = async (a) => await a\n```\n\n### `{\"anonymous\": \"never\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nvar bar = function () {\n    // ...\n};\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"never\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"never\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo () {\n    // ...\n}\n\nvar bar = function() {\n    // ...\n};\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n### `{\"anonymous\": \"ignore\", \"named\": \"always\"}`\n\nExamples of **incorrect** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nfunction foo() {\n    // ...\n}\n\nclass Foo {\n    constructor() {\n        // ...\n    }\n}\n\nvar foo = {\n    bar() {\n        // ...\n    }\n};\n```\n\nExamples of **correct** code for this rule with the `{\"anonymous\": \"ignore\", \"named\": \"always\"}` option:\n\n```js\n/*eslint space-before-function-paren: [\"error\", { \"anonymous\": \"ignore\", \"named\": \"always\" }]*/\n/*eslint-env es6*/\n\nvar bar = function() {\n    // ...\n};\n\nvar bar = function () {\n    // ...\n};\n\nfunction foo () {\n    // ...\n}\n\nclass Foo {\n    constructor () {\n        // ...\n    }\n}\n\nvar foo = {\n    bar () {\n        // ...\n    }\n};\n```\n\n## When Not To Use It\n\nYou can turn this rule off if you are not concerned with the consistency of spacing before function parenthesis.\n\n## Related Rules\n\n* [space-after-keywords](space-after-keywords.md)\n* [space-return-throw-case](space-return-throw-case.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 31,
           "column": 17
         },
         "end": {
           "line": 31,
           "column": 17
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 33,
           "column": 35
         },
         "end": {
           "line": 33,
           "column": 35
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 34,
           "column": 69
         },
         "end": {
           "line": 34,
           "column": 69
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 37,
           "column": 14
         },
         "end": {
           "line": 37,
           "column": 14
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "0b2053ec6ab19febc6f705da0929d55d",
     "type": "issue",
     "categories": [
       "Bug Risk"
     ],
     "check_name": "no-const-assign",
     "description": "'a' is constant.",
     "content": {
       "body": "# Disallow modifying variables that are declared using `const` (no-const-assign)\n\nWe cannot modify variables that are declared using `const` keyword.\nIt will raise a runtime error.\n\nUnder non ES2015 environment, it might be ignored merely.\n\n## Rule Details\n\nThis rule is aimed to flag modifying variables that are declared using `const` keyword.\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na = 1;\n```\n\n```js\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na += 1;\n```\n\n```js\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\n++a;\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\nconsole.log(a);\n```\n\n```js\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a in [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}\n```\n\n```js\n/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a of [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}\n```\n\n## When Not To Use It\n\nIf you don't want to be notified about modifying variables that are declared using `const` keyword, you can safely disable this rule.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 38,
           "column": 3
         },
         "end": {
           "line": 38,
           "column": 3
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "169a050016f531669510a14bf398fed3",
     "type": "issue",
     "categories": [
       "Bug Risk"
     ],
     "check_name": "no-unused-vars",
     "description": "'a' is assigned a value but never used.",
     "content": {
       "body": "# Disallow Unused Variables (no-unused-vars)\n\nVariables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers.\n\n## Rule Details\n\nThis rule is aimed at eliminating unused variables, functions, and function parameters.\n\nA variable `foo` is considered to be used if any of the following are true:\n\n* It is called (`foo()`) or constructed (`new foo()`)\n* It is read (`var bar = foo`)\n* It is passed into a function as an argument (`doSomething(foo)`)\n* It is read inside of a function that is passed to another function (`doSomething(function() { foo(); })`)\n\nA variable is *not* considered to be used if it is only ever declared (`var foo = 5`) or assigned to (`foo = 7`).\n\nExamples of **incorrect** code for this rule:\n\n```js\n/*eslint no-unused-vars: \"error\"*/\n/*global some_unused_var*/\n\n// It checks variables you have defined as global\nsome_unused_var = 42;\n\nvar x;\n\n// Write-only variables are not considered as used.\nvar y = 10;\ny = 5;\n\n// A read for a modification of itself is not considered as used.\nvar z = 0;\nz = z + 1;\n\n// By default, unused arguments cause warnings.\n(function(foo) {\n    return 5;\n})();\n\n// Unused recursive functions also cause warnings.\nfunction fact(n) {\n    if (n < 2) return 1;\n    return n * fact(n - 1);\n}\n\n// When a function definition destructures an array, unused entries from the array also cause warnings.\nfunction getY([x, y]) {\n    return y;\n}\n```\n\nExamples of **correct** code for this rule:\n\n```js\n/*eslint no-unused-vars: \"error\"*/\n\nvar x = 10;\nalert(x);\n\n// foo is considered used here\nmyFunc(function foo() {\n    // ...\n}.bind(this));\n\n(function(foo) {\n    return foo;\n})();\n\nvar myFunc;\nmyFunc = setTimeout(function() {\n    // myFunc is considered used\n    myFunc();\n}, 50);\n\n// Only the second argument from the descructured array is used.\nfunction getY([, y]) {\n    return y;\n}\n```\n\n### exported\n\nIn environments outside of CommonJS or ECMAScript modules, you may use `var` to create a global variable that may be used by other scripts. You can use the `/* exported variableName */` comment block to indicate that this variable is being exported and therefore should not be considered unused.\n\nNote that `/* exported */` has no effect for any of the following:\n\n* when the environment is `node` or `commonjs`\n* when `parserOptions.sourceType` is `module`\n* when `ecmaFeatures.globalReturn` is `true`\n\nThe line comment `// exported variableName` will not work as `exported` is not line-specific.\n\nExamples of **correct** code for `/* exported variableName */` operation:\n\n```js\n/* exported global_var */\n\nvar global_var = 42;\n```\n\n## Options\n\nThis rule takes one argument which can be a string or an object. The string settings are the same as those of the `vars` property (explained below).\n\nBy default this rule is enabled with `all` option for variables and `after-used` for arguments.\n\n```json\n{\n    \"rules\": {\n        \"no-unused-vars\": [\"error\", { \"vars\": \"all\", \"args\": \"after-used\", \"ignoreRestSiblings\": false }]\n    }\n}\n```\n\n### vars\n\nThe `vars` option has two settings:\n\n* `all` checks all variables for usage, including those in the global scope. This is the default setting.\n* `local` checks only that locally-declared variables are used but will allow global variables to be unused.\n\n#### vars: local\n\nExamples of **correct** code for the `{ \"vars\": \"local\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"vars\": \"local\" }]*/\n/*global some_unused_var */\n\nsome_unused_var = 42;\n```\n\n### varsIgnorePattern\n\nThe `varsIgnorePattern` option specifies exceptions not to check for usage: variables whose names match a regexp pattern. For example, variables whose names contain `ignored` or `Ignored`.\n\nExamples of **correct** code for the `{ \"varsIgnorePattern\": \"[iI]gnored\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"[iI]gnored\" }]*/\n\nvar firstVarIgnored = 1;\nvar secondVar = 2;\nconsole.log(secondVar);\n```\n\n### args\n\nThe `args` option has three settings:\n\n* `after-used` - unused positional arguments that occur before the last used argument will not be checked, but all named arguments and all positional arguments after the last used argument will be checked.\n* `all` - all named arguments must be used.\n* `none` - do not check arguments.\n\n#### args: after-used\n\nExamples of **incorrect** code for the default `{ \"args\": \"after-used\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"args\": \"after-used\" }]*/\n\n// 2 errors, for the parameters after the last used parameter (bar)\n// \"baz\" is defined but never used\n// \"qux\" is defined but never used\n(function(foo, bar, baz, qux) {\n    return bar;\n})();\n```\n\nExamples of **correct** code for the default `{ \"args\": \"after-used\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", {\"args\": \"after-used\"}]*/\n\n(function(foo, bar, baz, qux) {\n    return qux;\n})();\n```\n\n#### args: all\n\nExamples of **incorrect** code for the `{ \"args\": \"all\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"args\": \"all\" }]*/\n\n// 2 errors\n// \"foo\" is defined but never used\n// \"baz\" is defined but never used\n(function(foo, bar, baz) {\n    return bar;\n})();\n```\n\n#### args: none\n\nExamples of **correct** code for the `{ \"args\": \"none\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"args\": \"none\" }]*/\n\n(function(foo, bar, baz) {\n    return bar;\n})();\n```\n\n### ignoreRestSiblings\n\nThe `ignoreRestSiblings` option is a boolean (default: `false`). Using a [Rest Property](https://github.com/tc39/proposal-object-rest-spread) it is possible to \"omit\" properties from an object, but by default the sibling properties are marked as \"unused\". With this option enabled the rest property's siblings are ignored.\n\nExamples of **correct** code for the `{ \"ignoreRestSiblings\": true }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"ignoreRestSiblings\": true }]*/\n// 'type' is ignored because it has a rest property sibling.\nvar { type, ...coords } = data;\n```\n\n### argsIgnorePattern\n\nThe `argsIgnorePattern` option specifies exceptions not to check for usage: arguments whose names match a regexp pattern. For example, variables whose names begin with an underscore.\n\nExamples of **correct** code for the `{ \"argsIgnorePattern\": \"^_\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nfunction foo(x, _y) {\n    return x + 1;\n}\nfoo();\n```\n\n### caughtErrors\n\nThe `caughtErrors` option is used for `catch` block arguments validation.\n\nIt has two settings:\n\n* `none` - do not check error objects. This is the default setting.\n* `all` - all named arguments must be used.\n\n#### caughtErrors: none\n\nNot specifying this rule is equivalent of assigning it to `none`.\n\nExamples of **correct** code for the `{ \"caughtErrors\": \"none\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"none\" }]*/\n\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}\n```\n\n#### caughtErrors: all\n\nExamples of **incorrect** code for the `{ \"caughtErrors\": \"all\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"all\" }]*/\n\n// 1 error\n// \"err\" is defined but never used\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}\n```\n\n### caughtErrorsIgnorePattern\n\nThe `caughtErrorsIgnorePattern` option specifies exceptions not to check for usage: catch arguments whose names match a regexp pattern. For example, variables whose names begin with a string 'ignore'.\n\nExamples of **correct** code for the `{ \"caughtErrorsIgnorePattern\": \"^ignore\" }` option:\n\n```js\n/*eslint no-unused-vars: [\"error\", { \"caughtErrorsIgnorePattern\": \"^ignore\" }]*/\n\ntry {\n    //...\n} catch (ignoreErr) {\n    console.error(\"errors\");\n}\n```\n\n\n## When Not To Use It\n\nIf you don't want to be notified about unused variables or function arguments, you can safely turn this rule off.\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 38,
           "column": 3
         },
         "end": {
           "line": 38,
           "column": 3
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 38,
           "column": 8
         },
         "end": {
           "line": 38,
           "column": 8
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 41,
           "column": 32
         },
         "end": {
           "line": 41,
           "column": 32
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 42,
           "column": 22
         },
         "end": {
           "line": 42,
           "column": 22
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 43,
           "column": 3
         },
         "end": {
           "line": 43,
           "column": 3
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   },
   {
     "engine_name": "eslint",
     "fingerprint": "04e92edfccd38b738f51a2197c4a6677",
     "type": "issue",
     "categories": [
       "Clarity"
     ],
     "check_name": "semi",
     "description": "Extra semicolon.",
     "content": {
       "body": "# require or disallow semicolons instead of ASI (semi)\n\nJavaScript doesn't require semicolons at the end of each statement. In many cases, the JavaScript engine can determine that a semicolon should be in a certain spot and will automatically add it. This feature is known as **automatic semicolon insertion (ASI)** and is considered one of the more controversial features of JavaScript. For example, the following lines are both valid:\n\n```js\nvar name = \"ESLint\"\nvar website = \"eslint.org\";\n```\n\nOn the first line, the JavaScript engine will automatically insert a semicolon, so this is not considered a syntax error. The JavaScript engine still knows how to interpret the line and knows that the line end indicates the end of the statement.\n\nIn the debate over ASI, there are generally two schools of thought. The first is that we should treat ASI as if it didn't exist and always include semicolons manually. The rationale is that it's easier to always include semicolons than to try to remember when they are or are not required, and thus decreases the possibility of introducing an error.\n\nHowever, the ASI mechanism can sometimes be tricky to people who are using semicolons. For example, consider this code:\n\n```js\nreturn\n{\n    name: \"ESLint\"\n};\n```\n\nThis may look like a `return` statement that returns an object literal, however, the JavaScript engine will interpret this code as:\n\n```js\nreturn;\n{\n    name: \"ESLint\";\n}\n```\n\nEffectively, a semicolon is inserted after the `return` statement, causing the code below it (a labeled literal inside a block) to be unreachable. This rule and the [no-unreachable](no-unreachable.md) rule will protect your code from such cases.\n\nOn the other side of the argument are those who say that since semicolons are inserted automatically, they are optional and do not need to be inserted manually. However, the ASI mechanism can also be tricky to people who don't use semicolons. For example, consider this code:\n\n```js\nvar globalCounter = { }\n\n(function () {\n    var n = 0\n    globalCounter.increment = function () {\n        return ++n\n    }\n})()\n```\n\nIn this example, a semicolon will not be inserted after the first line, causing a run-time error (because an empty object is called as if it's a function). The [no-unexpected-multiline](no-unexpected-multiline.md) rule can protect your code from such cases.\n\nAlthough ASI allows for more freedom over your coding style, it can also make your code behave in an unexpected way, whether you use semicolons or not. Therefore, it is best to know when ASI takes place and when it does not, and have ESLint protect your code from these potentially unexpected cases. In short, as once described by Isaac Schlueter, a `\\n` character always ends a statement (just like a semicolon) unless one of the following is true:\n\n1. The statement has an unclosed paren, array literal, or object literal or ends in some other way that is not a valid way to end a statement. (For instance, ending with `.` or `,`.)\n1. The line is `--` or `++` (in which case it will decrement/increment the next token.)\n1. It is a `for()`, `while()`, `do`, `if()`, or `else`, and there is no `{`\n1. The next line starts with `[`, `(`, `+`, `*`, `/`, `-`, `,`, `.`, or some other binary operator that can only be found between two tokens in a single expression.\n\n## Rule Details\n\nThis rule enforces consistent use of semicolons.\n\n## Options\n\nThis rule has two options, a string option and an object option.\n\nString option:\n\n* `\"always\"` (default) requires semicolons at the end of statements\n* `\"never\"` disallows semicolons as the end of statements (except to disambiguate statements beginning with `[`, `(`, `/`, `+`, or `-`)\n\nObject option (when `\"always\"`):\n\n* `\"omitLastInOneLineBlock\": true` ignores the last semicolon in a block in which its braces (and therefore the content of the block) are in the same line\n\nObject option (when `\"never\"`):\n\n* `\"beforeStatementContinuationChars\": \"any\"` (default) ignores semicolons (or lacking semicolon) at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"always\"` requires semicolons at the end of statements if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n* `\"beforeStatementContinuationChars\": \"never\"` disallows semicolons as the end of statements if it doesn't make ASI hazard even if the next line starts with `[`, `(`, `/`, `+`, or `-`.\n\n### always\n\nExamples of **incorrect** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: [\"error\", \"always\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n```\n\nExamples of **correct** code for this rule with the default `\"always\"` option:\n\n```js\n/*eslint semi: \"error\"*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\n### never\n\nExamples of **incorrect** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\";\n\nobject.method = function() {\n    // ...\n};\n```\n\nExamples of **correct** code for this rule with the `\"never\"` option:\n\n```js\n/*eslint semi: [\"error\", \"never\"]*/\n\nvar name = \"ESLint\"\n\nobject.method = function() {\n    // ...\n}\n\nvar name = \"ESLint\"\n\n;(function() {\n    // ...\n})()\n\nimport a from \"a\"\n(function() {\n    // ...\n})()\n\nimport b from \"b\"\n;(function() {\n    // ...\n})()\n```\n\n#### omitLastInOneLineBlock\n\nExamples of additional **correct** code for this rule with the `\"always\", { \"omitLastInOneLineBlock\": true }` options:\n\n```js\n/*eslint semi: [\"error\", \"always\", { \"omitLastInOneLineBlock\": true}] */\n\nif (foo) { bar() }\n\nif (foo) { bar(); baz() }\n```\n\n#### beforeStatementContinuationChars\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"always\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"always\"}] */\nimport a from \"a\"\n\n(function() {\n    // ...\n})()\n```\n\nExamples of additional **incorrect** code for this rule with the `\"never\", { \"beforeStatementContinuationChars\": \"never\" }` options:\n\n```js\n/*eslint semi: [\"error\", \"never\", { \"beforeStatementContinuationChars\": \"never\"}] */\nimport a from \"a\"\n\n;(function() {\n    // ...\n})()\n```\n\n## When Not To Use It\n\nIf you do not want to enforce semicolon usage (or omission) in any particular way, then you can turn this rule off.\n\n## Further Reading\n\n* [An Open Letter to JavaScript Leaders Regarding Semicolons](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)\n* [JavaScript Semicolon Insertion](http://inimino.org/~inimino/blog/javascript_semicolons)\n\n## Related Rules\n\n* [no-extra-semi](no-extra-semi.md)\n* [no-unexpected-multiline](no-unexpected-multiline.md)\n* [semi-spacing](semi-spacing.md)\nSource: http://eslint.org/docs/rules/\n"
     },
     "location": {
       "path": "src/app.js",
       "positions": {
         "begin": {
           "line": 45,
           "column": 21
         },
         "end": {
           "line": 45,
           "column": 21
         }
       }
     },
     "remediation_points": 50000,
     "severity": "minor"
   }
 ]